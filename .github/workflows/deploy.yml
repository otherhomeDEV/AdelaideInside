name: Deploy to Server

on:
  push:
    branches:
      - main  # 원하는 브랜치를 지정합니다.

jobs:
  Devdeploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Print current directory
        run: pwd

      - name: List files
        run: ls -la

      - name: Install sshpass
        run: sudo apt-get install -y sshpass

      - name: Deploy via SCP with password
        run: |
          sshpass -p ${{ secrets.FTP_PASSWORD }} rsync -avz --exclude={'config.php','data'} -e "ssh -o StrictHostKeyChecking=no" /home/runner/work/test/test/* ${{ secrets.FTP_USERNAME }}@${{ secrets.FTP_SERVER }}:/root/aidev

      - name: Restart Docker container  # Docker 컨테이너를 재시작합니다.
        run: sshpass -p ${{ secrets.FTP_PASSWORD }} ssh -o StrictHostKeyChecking=no ${{ secrets.FTP_USERNAME }}@${{ secrets.FTP_SERVER }} "docker restart DevAI"
        env:
          FTP_SERVER: ${{ secrets.FTP_SERVER }}  # FTP 서버 주소를 Secrets에서 가져와 환경 변수로 설정합니다.
          FTP_USERNAME: ${{ secrets.FTP_USERNAME }}  # FTP 사용자 이름을 Secrets에서 가져와 환경 변수로 설정합니다.
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}  # FTP 비밀번호를 Secrets에서 가져와 환경 변수로 설정합니다.

  production:
    runs-on: ubuntu-latest
    needs: Devdeploy
    environment: production

    steps:
      - uses: actions/checkout@v2
      - run: echo 'production deployment'      

  Prodeploy:
    runs-on: ubuntu-latest
    needs: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Print current directory
        run: pwd

      - name: List files
        run: ls -la

      - name: Install sshpass
        run: sudo apt-get install -y sshpass
  
      - name: Deploy via SCP with password
        run: tar --exclude='config.php' --exclude='data' --exclude='./.*' --exclude=*.tar.gz --ignore-failed-read -cvzf deployment.tar.gz --overwrite -C /home/runner/work/test/test .

      - name: Transfer archive via SCP
        run: |
          if [ $? -eq 0 ]; then
            echo "Archive creation succeeded."
            sshpass -p "${{ secrets.CRAZY_PASSWORD }}" scp -o StrictHostKeyChecking=no deployment.tar.gz "${{ secrets.CRAZY_USERNAME }}@${{ secrets.CRAZY_SERVER }}:/home/${{ secrets.CRAZY_USERNAME }}/adelaideinside"
            if [ $? -eq 0 ]; then
              echo "SCP transfer succeeded."
            else
              echo "SCP transfer failed."
              exit 1
            fi
          else
            echo "Failed to create archive."
            exit 1
          fi
      
      - name: Extract and clean up remote archive
        run: |
          if [ $? -eq 0 ]; then
            sshpass -p "${{ secrets.CRAZY_PASSWORD }}" ssh -o StrictHostKeyChecking=no "${{ secrets.CRAZY_USERNAME }}@${{ secrets.CRAZY_SERVER }}" 'tar -xzf /home/${{ secrets.CRAZY_USERNAME }}/adelaideinside/deployment.tar.gz -C /home/${{ secrets.CRAZY_USERNAME }}/public_html && rm /home/${{ secrets.CRAZY_USERNAME }}/adelaideinside/deployment.tar.gz'
            if [ $? -eq 0 ]; then
              echo "Remote extraction and cleanup succeeded."
            else
              echo "Failed to extract or clean up remote archive."
              exit 1
            fi
          fi  
             
             
               
      #- name: Restart Docker container
      #  run: sshpass -p ${{ secrets.FTP_PASSWORD }} ssh -o StrictHostKeyChecking=no ${{ secrets.FTP_USERNAME }}@${{ secrets.FTP_SERVER }} "docker restart DevAI"
      #  env:
      #    FTP_SERVER: ${{ secrets.FTP_SERVER }}
      #    FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
      #    FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}

  ReleaseTag:
    runs-on: ubuntu-latest
    needs: Prodeploy

    steps:
      - name: Bump version and push tag
        id: tag_version
        uses: mathieudutour/github-tag-action@v6.1 
        with:
          github_token: ${{ secrets.ACCESS_TOKEN }}

      - name: Check if new_tag exists
        id: check_tag
        run: |
          echo "NEW_TAG=${{ steps.tag_version.outputs.new_tag }}" >> $GITHUB_ENV    

      - name: Release 생성
        uses: ncipollo/release-action@v1 
        with: 
          token: ${{ secrets.ACCESS_TOKEN }}
          tag: ${{ steps.tag_version.outputs.new_tag }} 
          name: ${{ steps.tag_version.outputs.new_tag }}
          body: ${{ steps.tag_version.outputs.changelog }}

  #approval:
  #  needs: deploy  # deploy 작업이 완료된 후에 approval 작업이 실행
  #  runs-on: ubuntu-latest

    #steps:
    #  - name: Send approval request
    #    uses: varu3/slack-approval@main
    #    env:
    #      SLACK_APP_TOKEN: ${{ secrets.SLACK_APP_TOKEN }}
    #      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
    #      SLACK_SIGNING_SECRET: ${{ secrets.SLACK_SIGNING_SECRET }}
    #      SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
    #    timeout-minutes: 15
     
    #steps:
    #  - name: Request Approval from kayden
    #    env:
    #      ENVIRONMENT: kayden
    #    run: echo "Asked for approval from $ENVIRONMENT"   

 

    #- name: Send Approval Request 되라
    #  if: always()  # 항상 실행되도록 설정합니다.
    #  uses: 8398a7/action-slack@v3
    #  with:
    #    status: ${{ job.status }}
    #    author_name: www-be
    #    fields: repo,message,commit,author,action,eventName,ref,workflow,job,took
    #    if_mention: failure,cancelled
    #    text: "Deployment to DEV server completed successfully. Please approve deployment to production."
    #    github_token: ${{ secrets.ACCESS_TOKEN}}
    #  env:
    #    SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}  # Slack 웹후크 URL 설정d
     
